<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pat Browne</title>
    <link>https://patbrowne.com/</link>
    <description>Recent content on Pat Browne</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://patbrowne.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Belichick&#39;s library</title>
      <link>https://patbrowne.com/posts/belichick-about/</link>
      <pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/belichick-about/</guid>
      <description>&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://patbrowne.com/belichick/&#34;&gt;Back to catalogue&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;about-this-page&#34;&gt;About This Page&lt;/h2&gt;
&lt;p&gt;This is intended to be an outline of a (future) blog post explaining the page,
how I made it, and anything else interesting about the process of creating
it. Possible section headers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Info on collection. From articles, press releases, interviews, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Statistics: categories, dates, keywords, &amp;hellip;&lt;/li&gt;
&lt;li&gt;Links that I chose to include, why, and something about each&lt;/li&gt;
&lt;li&gt;ISBNs and how they came to be&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Approximate_string_matching&#34;&gt;Fuzzy string
searching&lt;/a&gt;, how the
webpage searches for books and handles typos and related words&lt;/li&gt;
&lt;li&gt;Thoughts on data cleaning and use of AI in this process&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;search-links&#34;&gt;Search Links&lt;/h3&gt;
&lt;p&gt;Each book has links to four sites.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building circuits with the 74HC595 (Part 1)</title>
      <link>https://patbrowne.com/posts/shiftreg1/</link>
      <pubDate>Tue, 10 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/shiftreg1/</guid>
      <description>&lt;p&gt;&lt;em&gt;This is the first of two posts about shift registers. This post focuses on some
history behind integrated circuits, how the 74HC595 works, and how to build
simple circuits with it. The second post will explore more complex circuits, as
well as how shift registers are used today.&lt;/em&gt;&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;img
src=&#34;https://patbrowne.com/img/shiftreg/sn74hc595n-image.jpg&#34;
alt=&#34;Image of an SN74HC595N integrated circuit&#34; width=&#34;35%&#34;&gt;
&lt;br&gt;
Many general-purpose electronics kits include a few integrated circuits (ICs) in
addition to jumper wires, resistors, capacitors, and other electronic circuit
components. A common IC included in kits is the 74HC595N, often one manufactured
by Texas Instruments (SN74HC595N). After receiving a few of these in various
electronics kits, I built several circuits with this shift register to
understand how it works.&lt;br&gt;&lt;br&gt;
&lt;h2 id=&#34;background-on-integrated-circuits&#34;&gt;Background on integrated circuits&lt;/h2&gt;
&lt;p&gt;Circuits are made up of electrical components, such as resistors, capacitors,
transistors, and diodes. While all circuits can be made up of these components,
it is often necessary to combine several parts together into a single component,
where the parts are closer together, smaller, and merged into a single building
block. These circuits are typically etched onto a semiconductor material, such
as silicon, and are known as &lt;strong&gt;integrated circuits&lt;/strong&gt;, or &lt;strong&gt;ICs&lt;/strong&gt; for short.&lt;/p&gt;</description>
    </item>
    <item>
      <title>SAL/SAR/SHL/SHR — Shift</title>
      <link>https://patbrowne.com/posts/sal/</link>
      <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/sal/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been &lt;a href=&#34;https://github.com/pbrowne011/tcpl-solutions/tree/main&#34;&gt;working through some of the
exercises&lt;/a&gt; from &lt;a href=&#34;https://en.wikipedia.org/wiki/The_C_Programming_Language&#34;&gt;&amp;ldquo;The C
Programming Language&amp;rdquo;&lt;/a&gt;
by Kernighan and Ritchie, and ran into an issue in Chapter 2 (&amp;ldquo;Types, Operators,
and Expressions&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exercise 2-7&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write a function &lt;code&gt;invert(x,p,n)&lt;/code&gt; that returns &lt;code&gt;x&lt;/code&gt; with the &lt;code&gt;n&lt;/code&gt; bits that begin
at position &lt;code&gt;p&lt;/code&gt; inverted (i.e., 1 changed into 0 and vice versa), leaving the
others unchanged.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This seemed easy enough, and I wrote the following function as a solution: &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Counting assembly instructions</title>
      <link>https://patbrowne.com/posts/countasm/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/countasm/</guid>
      <description>&lt;p&gt;As someone who may or may not procrastinate, I find myself &lt;a href=&#34;https://projects.csail.mit.edu/gsb/old-archive/gsb-archive/gsb2000-02-11.html&#34;&gt;shaving
yaks&lt;/a&gt;
occasionally. One such yak shave occurred recently while working on a project
for my operating systems class. We were provided with an assembly file written
in x86 GNU assembly syntax. I wondered if the file contained any instructions I
wasn&amp;rsquo;t familiar with or hadn&amp;rsquo;t used in awhile. My first task was to figure out
all of these unique assembly instructions, look them up in the Intel manual, and
use them (plus 1-2 others) for the code I was going to write.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Right to left computability</title>
      <link>https://patbrowne.com/posts/rtolcompute/</link>
      <pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/rtolcompute/</guid>
      <description>&lt;h3 id=&#34;manipulating-bits&#34;&gt;Manipulating bits&lt;/h3&gt;
&lt;p&gt;Recently I&amp;rsquo;ve been going through &lt;a href=&#34;https://en.wikipedia.org/wiki/Hacker&#39;s_Delight&#34;&gt;Hacker&amp;rsquo;s
Delight&lt;/a&gt;. It is a joy to become
a &amp;ldquo;bit-twiddler&amp;rdquo; and explore some of the counter intuitive properties of using
bit wise operations in places you wouldn&amp;rsquo;t expect them.&lt;/p&gt;
&lt;p&gt;Chapter 2 focuses on &amp;ldquo;Basics&amp;rdquo;, and covers bit manipulation tricks that perform
specific operations. It assumes a 32-bit machine (and word size), with signed
values represented in two&amp;rsquo;s complement form. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; Some tricks presented include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x \\; \\&amp; \\; (x - 1)$: turn off the rightmost bit in a word&lt;/li&gt;
&lt;li&gt;$x \\; \\&amp; \\; (x + 1)$: turn off the trailing 1&amp;rsquo;s in a word&lt;/li&gt;
&lt;li&gt;$\neg x \\; \\&amp; \\; (x + 1)$: create a word with a single 1-bit at the position of the
rightmost 0-bit&lt;/li&gt;
&lt;li&gt;$x \\; \\&amp; \\; (-x)$: isolate the rightmost 1-bit, produce 0 if none&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that these hacks are much more useful than they might appear. The first
trick can be used to great effect to count set bits and calculate powers of two,
as demonstrated in Brian Kernighan&amp;rsquo;s algorithm&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Understanding learning with errors</title>
      <link>https://patbrowne.com/posts/lwe/</link>
      <pubDate>Thu, 19 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/lwe/</guid>
      <description>&lt;p&gt;Cryptographic protocols that perform computations on encrypted data without
decrypting it are known as homomorphic encryption. &lt;a href=&#34;https://en.wikipedia.org/wiki/Homomorphic_encryption#Fully_homomorphic_encryption&#34;&gt;Fully homomorphic
encryption&lt;/a&gt;
(FHE) protocols, systems which support arbitrary computations, often rely on
different primitives than conventional cryptography systems. Most FHE systems in
practice used lattice-based cryptography, relying on a computational hardness
assumption known as the learning with errors (LWE) problem.&lt;/p&gt;
&lt;h2 id=&#34;cryptograhy-relies-on-assumptions&#34;&gt;Cryptograhy relies on assumptions&lt;/h2&gt;
&lt;p&gt;Prior to the 20th century, cryptography did not rely on a formalized system of
provable security. Rather, one set of people (cryptographers) would come up with
clever ciphers, and another set of people (cryptanalysts) would attempt to break
those ciphers. Encryption schemes such as the Caesar cipher, the Vingenère
cipher, the Enigma, and other systems were not formally proven secure by
cryptographers. Rather, they relied on obfuscation and statistical properties
that made deciphering messages fairly difficult. However, each one of these
systems had some sort of flaw that cryptanalysts were able to exploit to
decipher encrypted messages. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Real-life examples of Markov chains</title>
      <link>https://patbrowne.com/posts/markov/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/markov/</guid>
      <description>&lt;p&gt;One of the classes that I&amp;rsquo;m taking this semester is on
&lt;a href=&#34;https://www.bu.edu/academics/cas/courses/cas-ma-583/&#34;&gt;stochastic processes&lt;/a&gt;.
Stochastic processes are sequences of random variables $X_1, X_2, ..., X_n$,
where $n$ represents a specific moment in time.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; The first topic we&amp;rsquo;ve
focused on this semester has been
&lt;a href=&#34;https://en.wikipedia.org/wiki/Markov_chain&#34;&gt;Markov chains&lt;/a&gt;, specific
stochastic models that only depend on the current state. They are unique in
that future events are only affected by where you currently are, not where you
have been in the past. Markov chains arise from the
&lt;a href=&#34;https://statproofbook.github.io/P/prob-tot.html&#34;&gt;law of total probability&lt;/a&gt;,
which is a way to express the probability of an event as the sum of many other
probabilities. In general, when dealing with a stochastic process, you have
to condition the probability of an event on all previous events before, as they
all have some effect on whether or not you reach that state. Mathematically,
this can be expressed as&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why do commands require tabs in a Makefile?</title>
      <link>https://patbrowne.com/posts/makefile/</link>
      <pubDate>Sun, 03 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://patbrowne.com/posts/makefile/</guid>
      <description>&lt;p&gt;When I was first learning how to write a Makefile to compile a C program, one
thing that stuck me (and almost everyone who encounters it) as odd was the
requirement that each command line start with a tab character
(&lt;code&gt;&#39;\t&#39;&lt;/code&gt;). Makefiles are used to automate repetitive tasks (such as recompiling a
C/C++ program), and have a unique syntax. They are made up of rules, which
consist of a &amp;ldquo;target&amp;rdquo;, a list of &amp;ldquo;dependencies&amp;rdquo;, and a series of
&amp;ldquo;commands&amp;rdquo;. They look like this:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
